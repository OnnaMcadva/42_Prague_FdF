## MiniLibX:

1. **`mlx_init()`**
   - Инициализирует соединение с сервером X Window и возвращает указатель на структуру, представляющую это соединение. Эта функция должна быть вызвана перед использованием других функций MiniLibX.

2. **`mlx_new_window(void *mlx_ptr, int width, int height, char *title)`**
   - Создает новое окно с заданной шириной, высотой и заголовком. Возвращает указатель на структуру окна. `mlx_ptr` — указатель, полученный от `mlx_init()`.

3. **`mlx_clear_window(void *mlx_ptr, void *win_ptr)`**
   - Очищает содержимое указанного окна, делая его полностью черным. `win_ptr` — указатель на окно, полученный от `mlx_new_window()`.

4. **`mlx_destroy_window(void *mlx_ptr, void *win_ptr)`**
   - Закрывает и уничтожает указанное окно. Освобождает ресурсы, связанные с этим окном.

5. **`mlx_new_image(void *mlx_ptr, int width, int height)`**
   - Создает новое изображение (буфер) заданной ширины и высоты. Возвращает указатель на структуру изображения.

6. **`mlx_destroy_image(void *mlx_ptr, void *img_ptr)`**
   - Уничтожает указанное изображение и освобождает связанные с ним ресурсы.

7. **`mlx_get_data_addr(void *img_ptr, int *bits_per_pixel, int *size_line, int *endian)`**
   - Возвращает указатель на пиксельные данные изображения. Также заполняет переданные переменные информацией о формате изображения:
     - `bits_per_pixel` — количество бит на пиксель.
     - `size_line` — количество байтов на одну строку изображения.
     - `endian` — порядок байтов (0 — little endian, 1 — big endian).

8. **`mlx_put_image_to_window(void *mlx_ptr, void *win_ptr, void *img_ptr, int x, int y)`**
   - Отображает изображение в указанном окне по заданным координатам (x, y).

9. **`mlx_hook(void *win_ptr, int x_event, int x_mask, int (*funct_ptr)(), void *param)`**
   - Устанавливает обработчик событий для окна. 
     - `x_event` — тип события (например, нажатие клавиши, движение мыши и т.д.).
     - `x_mask` — маска событий.
     - `funct_ptr` — указатель на функцию-обработчик событий.
     - `param` — параметр, который будет передан в функцию-обработчик.

10. **`mlx_mouse_hook(void *win_ptr, int (*funct_ptr)(), void *param)`**
    - Устанавливает обработчик событий для событий мыши в окне. 
      - `funct_ptr` — указатель на функцию-обработчик событий мыши.
      - `param` — параметр, который будет передан в функцию-обработчик.

11. **`mlx_loop(void *mlx_ptr)`**
    - Запускает главный цикл обработки событий. Эта функция не возвращает управление, пока не будет закрыто основное окно или программа не завершит работу.

12. **`mlx_xpm_file_to_image(void *mlx_ptr, char *filename, int *width, int *height)`**
    - Загружает изображение в формате XPM (X PixMap) из файла и создает новое изображение. 
      - `width` и `height` заполняются размерами загруженного изображения.
      - Возвращает указатель на структуру изображения.


## Цвет в формате ARGB (32-битный целочисленный) представлен следующим образом:

   * A (альфа-канал) — старшие 8 бит (24-31)
   * R (красный) — следующие 8 бит (16-23)
   * G (зеленый) — следующие 8 бит (8-15)
   * B (синий) — младшие 8 бит (0-7)
### Обработка цвета

* Синий (B) обрабатывается первым: поскольку он находится в младших 8 битах (0-7), он извлекается без сдвига ((min_color >> 0) & 255).
* Зеленый (G) обрабатывается вторым: он находится в следующих 8 битах (8-15), поэтому требуется сдвиг на 8 бит вправо ((min_color >> 8) & 255).
* Красный (R) обрабатывается третьим: он находится в битах 16-23, поэтому сдвиг на 16 бит ((min_color >> 16) & 255).
* Альфа-канал (A) обрабатывается последним: он находится в старших 8 битах (24-31), поэтому сдвиг на 24 бита ((min_color >> 24) & 255).
  
![изображение](https://github.com/OnnaMcadva/42_Prague_FdF/assets/94723781/07eb0644-c049-422e-b649-66a541866828)

### Коды ASCII используются в программировании как промежуточные кроссплатформенные коды нажатых клавиш (в противовес скан-кодам IBM PC и прочим внутренним кодам). Для раскладки клавиатуры QWERTY — таблица кодов выглядит так, как показано в следующей таблице.

![Screenshot from 2024-06-15 18-31-01](https://github.com/OnnaMcadva/42_Prague_FdF/assets/94723781/6177bc8e-6dde-4279-8d65-93f49c8ff77c)


`xev` (X Event Viewer) — это утилита в системе X11, которая позволяет отслеживать и отображать события, происходящие в графической системе X11. Эта утилита полезна для определения кодов клавиш и других событий, происходящих с устройствами ввода (например, клавиатурой и мышью).

### Как установить и использовать `xev`

1. **Установка `xev`**:
   В большинстве дистрибутивов Linux `xev` входит в пакет `x11-utils`. Чтобы установить этот пакет, используйте менеджер пакетов вашей системы. Например:

   - В Ubuntu или Debian:
     ```sh
     sudo apt-get install x11-utils
     ```

   - В Fedora:
     ```sh
     sudo dnf install xev
     ```

   - В Arch Linux:
     ```sh
     sudo pacman -S xorg-xev
     ```

2. **Запуск `xev`**:
   Чтобы запустить `xev`, просто введите команду `xev` в терминале:
   ```sh
   xev
   ```

   Это откроет небольшое окно. Когда это окно активно, события клавиатуры и мыши будут регистрироваться и отображаться в терминале.

3. **Определение кода клавиши**:
   Когда окно `xev` активно, нажмите любую клавишу, которую хотите определить. В терминале появится информация о событии клавиши. Найдите строку, которая содержит `keycode` и `keysym`. Например:

   ```sh
   KeyPress event, serial 40, synthetic NO, window 0x2a00001,
       root 0x7a2, subw 0x0, time 123456789, (34,78), root:(123,456),
       state 0x0, keycode 38 (keysym 0x61, a), same_screen YES,
       XLookupString gives 1 bytes: (61) "a"
       XmbLookupString gives 1 bytes: (61) "a"
       XFilterEvent returns: False
   ```

   В этом примере `keycode` равен 38, а `keysym` — 0x61, что соответствует клавише `a`.

### Пример использования `xev` для определения кода клавиши `Escape`

1. Запустите `xev`:
   ```sh
   xev
   ```

2. Нажмите клавишу `Escape`. Вы увидите что-то похожее на это:
   ```sh
   KeyPress event, serial 40, synthetic NO, window 0x2a00001,
       root 0x7a2, subw 0x0, time 123456789, (34,78), root:(123,456),
       state 0x0, keycode 9 (keysym 0xff1b, Escape), same_screen YES,
       XLookupString gives 1 bytes: (1b) ""
       XmbLookupString gives 1 bytes: (1b) ""
       XFilterEvent returns: False
   ```

   Здесь `keycode` равен 9, а `keysym` — 0xff1b, что соответствует клавише `Escape`.

### Итог

`xev` — это полезный инструмент для определения кодов клавиш и других событий ввода в X11. С его помощью можно проверить и убедиться, что коды клавиш, используемые в вашем коде, правильные и соответствуют нужным клавишам на вашей клавиатуре.
